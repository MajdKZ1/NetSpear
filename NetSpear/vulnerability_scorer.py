"""
Vulnerability prioritization and scoring system with CVSS integration.
"""
import logging
import re
from typing import Optional, Dict, List, Any
from datetime import datetime, timezone
from sqlalchemy.orm import Session

from database import get_db_manager, Vulnerability

logger = logging.getLogger(__name__)


class VulnerabilityScorer:
    """Score and prioritize vulnerabilities."""
    
    def __init__(self, db_session: Optional[Session] = None):
        """
        Initialize vulnerability scorer.
        
        Args:
            db_session: Optional database session
        """
        self.db = get_db_manager()
        self.db_session = db_session
    
    def _get_session(self) -> Session:
        """Get or create database session."""
        return self.db_session or self.db.get_session()
    
    def calculate_cvss_score(self, cve: Optional[str], description: Optional[str] = None, cvss_score: Optional[float] = None) -> Optional[float]:
        """
        Calculate CVSS score for a vulnerability.
        
        Args:
            cve: CVE identifier
            description: Vulnerability description
            cvss_score: Pre-calculated CVSS score (from advanced scanner)
            
        Returns:
            CVSS score (0.0-10.0) or None
        """
        # If CVSS score is already provided (from advanced scanner), use it
        if cvss_score is not None:
            return float(cvss_score)
        
        if not cve and not description:
            return None
        
        # Try to use advanced scanner if available
        try:
            from advanced_vuln_scanner import AdvancedVulnerabilityScanner
            advanced_scanner = AdvancedVulnerabilityScanner()
            cve_data = advanced_scanner._get_cve_details(cve) if cve else None
            if cve_data and cve_data.get("cvss_score"):
                return float(cve_data["cvss_score"])
        except Exception:
            pass  # Fall back to heuristics
        
        score = 5.0  # Default medium
        
        # Check for critical CVEs
        critical_cves = [
            "CVE-2017-0144",  # EternalBlue
            "CVE-2019-0708",  # BlueKeep
            "CVE-2020-1472",  # ZeroLogon
            "CVE-2021-44228",  # Log4Shell
            "CVE-2021-34527",  # PrintNightmare
        ]
        
        if cve in critical_cves:
            return 10.0
        
        # Heuristic scoring based on description
        if description:
            desc_lower = description.lower()
            
            # Critical indicators
            if any(term in desc_lower for term in ["remote code execution", "rce", "critical", "0-day", "zero-day", "log4shell", "eternalblue"]):
                score = 9.0
            # High indicators
            elif any(term in desc_lower for term in ["arbitrary code", "privilege escalation", "sqli", "xss", "command injection"]):
                score = 7.5
            # Medium indicators
            elif any(term in desc_lower for term in ["information disclosure", "denial of service", "dos", "path traversal"]):
                score = 5.0
            # Low indicators
            elif any(term in desc_lower for term in ["weak", "default", "misconfiguration", "missing header"]):
                score = 3.0
        
        # Adjust based on CVE year (newer CVEs often have better scoring)
        if cve:
            year_match = re.search(r'CVE-(\d{4})', cve)
            if year_match:
                year = int(year_match.group(1))
                if year >= 2020:
                    score += 0.5
        
        return min(10.0, max(0.0, score))
    
    def calculate_risk_score(
        self,
        cvss_score: Optional[float],
        asset_criticality: str = "medium",
        exploit_available: bool = False,
        exposure_level: str = "external",
    ) -> float:
        """
        Calculate overall risk score.
        
        Args:
            cvss_score: CVSS base score
            asset_criticality: Asset criticality (critical, high, medium, low)
            exploit_available: Whether exploit is available
            exposure_level: Exposure level (external, internal, restricted)
            
        Returns:
            Risk score (0.0-10.0)
        """
        base_score = cvss_score or 5.0
        
        # Adjust for asset criticality
        criticality_multiplier = {
            "critical": 1.2,
            "high": 1.1,
            "medium": 1.0,
            "low": 0.8,
        }.get(asset_criticality.lower(), 1.0)
        
        # Adjust for exploit availability
        if exploit_available:
            base_score *= 1.2
        
        # Adjust for exposure
        exposure_multiplier = {
            "external": 1.2,
            "internal": 1.0,
            "restricted": 0.8,
        }.get(exposure_level.lower(), 1.0)
        
        risk_score = base_score * criticality_multiplier * exposure_multiplier
        return min(10.0, max(0.0, risk_score))
    
    def prioritize_vulnerability(
        self,
        vulnerability_id: int,
        asset_criticality: Optional[str] = None,
        exposure_level: Optional[str] = None,
    ) -> Optional[Vulnerability]:
        """
        Score and prioritize a vulnerability.
        
        Args:
            vulnerability_id: Vulnerability ID
            asset_criticality: Asset criticality level
            exposure_level: Exposure level
            
        Returns:
            Updated vulnerability object
        """
        db = self._get_session()
        try:
            vuln = db.query(Vulnerability).filter(Vulnerability.id == vulnerability_id).first()
            if not vuln:
                return None
            
            # Calculate CVSS score (use existing if available)
            if not vuln.cvss_score:
                cvss_score = self.calculate_cvss_score(vuln.cve, vuln.description, vuln.cvss_score)
                if cvss_score:
                    vuln.cvss_score = cvss_score
            else:
                cvss_score = vuln.cvss_score
            
            # Determine severity from CVSS
            if cvss_score:
                if cvss_score >= 9.0:
                    vuln.severity = "critical"
                elif cvss_score >= 7.0:
                    vuln.severity = "high"
                elif cvss_score >= 4.0:
                    vuln.severity = "medium"
                else:
                    vuln.severity = "low"
            
            # Calculate risk score
            asset_crit = asset_criticality or vuln.asset_criticality or "medium"
            exposure = exposure_level or "internal"
            risk_score = self.calculate_risk_score(
                vuln.cvss_score,
                asset_crit,
                vuln.exploit_available,
                exposure,
            )
            vuln.risk_score = risk_score
            vuln.asset_criticality = asset_crit
            
            # Calculate remediation priority (1-10, higher is more urgent)
            priority = self._calculate_remediation_priority(risk_score, vuln.severity)
            vuln.remediation_priority = priority
            
            db.commit()
            db.refresh(vuln)
            
            logger.info(f"Prioritized vulnerability {vulnerability_id}: risk={risk_score:.2f}, priority={priority}")
            return vuln
        except Exception as e:
            db.rollback()
            logger.error(f"Failed to prioritize vulnerability: {e}")
            return None
    
    def _calculate_remediation_priority(self, risk_score: float, severity: Optional[str]) -> int:
        """Calculate remediation priority (1-10)."""
        # Base priority on risk score
        priority = int(risk_score)
        
        # Boost for critical severity
        if severity == "critical":
            priority = min(10, priority + 2)
        elif severity == "high":
            priority = min(10, priority + 1)
        
        return max(1, min(10, priority))
    
    def get_prioritized_vulnerabilities(
        self,
        target_ip: Optional[str] = None,
        limit: int = 100,
        min_risk_score: Optional[float] = None,
    ) -> List[Dict[str, Any]]:
        """
        Get prioritized vulnerabilities.
        
        Args:
            target_ip: Optional filter by target IP
            limit: Maximum number to return
            min_risk_score: Minimum risk score
            
        Returns:
            List of prioritized vulnerabilities
        """
        db = self._get_session()
        query = db.query(Vulnerability)
        
        if target_ip:
            from database import Scan
            query = query.join(Scan).filter(Scan.target_ip == target_ip)
        
        if min_risk_score is not None:
            query = query.filter(Vulnerability.risk_score >= min_risk_score)
        
        vulnerabilities = query.order_by(
            Vulnerability.remediation_priority.desc(),
            Vulnerability.risk_score.desc()
        ).limit(limit).all()
        
        return [v.to_dict() for v in vulnerabilities]
    
    def batch_prioritize(self, target_ip: Optional[str] = None) -> int:
        """
        Prioritize all vulnerabilities for a target or all vulnerabilities.
        
        Args:
            target_ip: Optional target IP filter
            
        Returns:
            Number of vulnerabilities prioritized
        """
        db = self._get_session()
        query = db.query(Vulnerability)
        
        if target_ip:
            from database import Scan
            query = query.join(Scan).filter(Scan.target_ip == target_ip)
        
        vulnerabilities = query.all()
        count = 0
        
        for vuln in vulnerabilities:
            if self.prioritize_vulnerability(vuln.id):
                count += 1
        
        return count

